name: Deploy bot (one or all)

on:
  workflow_dispatch:
    inputs:
      user:
        description: "User (ex: n8w0lff) ou 'all'"
        required: true
        type: string
      image_tag:
        description: "Tag da imagem (default: latest)"
        required: false
        default: "latest"
        type: string

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout infra repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials (role to assume)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: us-east-1

      - name: Parse tfvars for users
        id: parse
        shell: bash
        run: |
          set -euo pipefail

          USERS=$(grep -A 999 'users = {' terraform.tfvars | \
                  grep -E '^\s{2}[a-zA-Z0-9_]+\s*=\s*\{' | \
                  sed -E 's/^\s+([a-zA-Z0-9_]+).*/\1/' | \
                  jq -R . | jq -s -c .)

          echo "users=${USERS}" >> $GITHUB_OUTPUT

      - name: Determine targets
        id: targets
        shell: bash
        run: |
          set -euo pipefail
          REQ="${{ github.event.inputs.user }}"
          ALL=$(echo '${{ steps.parse.outputs.users }}' | jq -r '.[]')
          if [ "$REQ" = "all" ]; then
            TARGETS=$(printf "%s\n" $ALL | jq -R . | jq -s -c .)
          else
            TARGETS=$(printf "%s\n" "$REQ" | jq -R . | jq -s -c .)
          fi
          echo "targets=${TARGETS}" >> "$GITHUB_OUTPUT"

      - name: Rollout each target
        shell: bash
        run: |
          set -euo pipefail
          IMAGE_TAG="${{ github.event.inputs.image_tag }}"

          PROJECT=$(grep -E '^project_name' terraform.tfvars | awk -F\" '{print $2}')
          IMAGE=$(grep -E '^container_image' terraform.tfvars | awk -F\" '{print $2}')
          BASE_IMAGE="${IMAGE%:*}"

          for USER in $(echo '${{ steps.targets.outputs.targets }}' | jq -r '.[]'); do
            echo "==> Deploy para user: ${USER}"

            CLUSTER="${PROJECT}-cluster"
            SERVICE="${PROJECT}-${USER}"
            FAMILY="${PROJECT}-${USER}"

            # Verifica se o service existe
            if ! aws ecs describe-services \
              --cluster "$CLUSTER" \
              --services "$SERVICE" \
              --query 'services[0].serviceName' \
              --output text >/dev/null 2>&1; then
              echo "::error::Service '${SERVICE}' não existe. Execute o workflow 'Infra Apply' para criar o user '${USER}'."
              exit 1
            fi

            NEW_IMAGE="${BASE_IMAGE}:${IMAGE_TAG}"

            # ContainerDefinitions atuais com a nova imagem
            CONTAINERS_JSON=$(aws ecs describe-task-definition \
              --task-definition "$FAMILY" \
              --query 'taskDefinition.containerDefinitions' | jq -c '.[0].image = "'"$NEW_IMAGE"'"')

            # Demais atributos da task atual
            EXEC_ROLE=$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.executionRoleArn' --output text)
            TASK_ROLE=$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.taskRoleArn' --output text)
            NET_MODE=$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.networkMode' --output text)
            CPU=$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.cpu' --output text)
            MEM=$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.memory' --output text)
            REQS=$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.requiresCompatibilities' --output json)
            RUNTIME=$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.runtimePlatform' --output json)
            VOLUMES=$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.volumes' --output json)
            
            # Registra nova revisão da task definition
            NEW_TD_ARN=$(aws ecs register-task-definition \
              --family "$FAMILY" \
              --execution-role-arn "$EXEC_ROLE" \
              --task-role-arn "$TASK_ROLE" \
              --network-mode "$NET_MODE" \
              --requires-compatibilities $(echo "$REQS" | jq -r '.[]') \
              --cpu "$CPU" \
              --memory "$MEM" \
              --runtime-platform "$RUNTIME" \
              --volumes "$VOLUMES" \
              --container-definitions "$CONTAINERS_JSON" \
              --query 'taskDefinition.taskDefinitionArn' --output text)
          
          
            echo "✔ Nova task definition: $NEW_TD_ARN"

          # Atualiza o service para a nova revisão e força o restart
          aws ecs update-service \
            --cluster "$CLUSTER" \
            --service "$SERVICE" \
            --task-definition "$NEW_TD_ARN" \
            --force-new-deployment >/dev/null
          
          echo "✔ Service atualizado e forçado novo deploy: $SERVICE"

          done
