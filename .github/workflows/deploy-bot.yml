name: Deploy bot (one or all)

on:
  workflow_dispatch:
    inputs:
      user:
        description: "User (ex: n8w0lff) ou 'all'"
        required: true
        type: string
      image_tag:
        description: "Tag da imagem (default: latest)"
        required: false
        type: string
        default: "latest"

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout infra repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials (role to assume)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: us-east-1

      - name: Parse tfvars for users
        id: parse
        run: |
          set -euo pipefail
          USERS=$(python3 - <<'PY'
  import re, json
with open('terraform.tfvars','r') as f:
  s=f.read()
  m=re.search(r'users\s*=\s*{(.*?)}', s, re.S)
if not m:
  print(json.dumps([]))
  raise SystemExit
  block=m.group(1)
  keys=re.findall(r'(\w+)\s*=', block)
  print(json.dumps(keys))
  PY
  )
  echo "users=${USERS}" >> $GITHUB_OUTPUT

- name: Determine targets
  id: targets
  run: |
    set -euo pipefail
    REQ="${{ github.event.inputs.user }}"
    ALL=$(echo '${{ steps.parse.outputs.users }}' | jq -r '.[]')
    if [ "$REQ" = "all" ]; then
      TARGETS=$(printf "%s\n" $ALL | jq -R . | jq -s .)
    else
      TARGETS=$(printf "%s\n" "$REQ" | jq -R . | jq -s .)
    fi
    echo "targets=${TARGETS}" >> $GITHUB_OUTPUT

- name: Rollout each target
  run: |
    set -euo pipefail
    IMAGE_TAG="${{ github.event.inputs.image_tag }}"
    ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
    REGION="us-east-1"
    
    PROJECT=$(grep '^project_name' terraform.tfvars | awk -F\" '{print $2}')
    IMAGE=$(grep '^container_image' terraform.tfvars | awk -F\" '{print $2}')
    BASE_IMAGE="${IMAGE%:*}"
    
    for USER in $(echo '${{ steps.targets.outputs.targets }}' | jq -r '.[]'); do
      FAMILY="${PROJECT}-${USER}"
      SERVICE="${PROJECT}-${USER}"
      CLUSTER="${PROJECT}-cluster"
    
      echo "==> Deploy para user: ${USER}"
      # Verifica se o service existe
      if ! aws ecs describe-services --cluster "$CLUSTER" --services "$SERVICE" --query 'services[0].serviceName' --output text >/dev/null 2>&1; then
        echo "::error::Service ${SERVICE} não encontrado. Execute o workflow 'infra-apply' para fazer o onboarding do usuário '${USER}'."
        exit 1
      fi
    
      NEW_IMAGE="${BASE_IMAGE}:${IMAGE_TAG}"
    
      # Cria nova revisão da task definition com a mesma config, apenas trocando a imagem
      TD_ARN=$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.taskDefinitionArn' --output text)
    
      # Gera nova JSON de containerDefinitions trocando somente imagem
      CONTAINERS_JSON=$(aws ecs describe-task-definition --task-definition "$FAMILY" \
        --query 'taskDefinition.containerDefinitions' | jq '.[0].image = "'"$NEW_IMAGE"'" | [.]')
    
      # Registra nova revisão (reaproveitando atributos atuais)
      NEW_TD_ARN=$(aws ecs register-task-definition \
        --family "$FAMILY" \
        --execution-role-arn "$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.executionRoleArn' --output text)" \
        --network-mode "$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.networkMode' --output text)" \
        --requires-compatibilities "$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.requiresCompatibilities' --output text)" \
        --cpu "$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.cpu' --output text)" \
        --memory "$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.memory' --output text)" \
        --runtime-platform "$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.runtimePlatform' --output json)" \
        --volumes "$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.volumes' --output json)" \
        --container-definitions "$CONTAINERS_JSON" \
        --query 'taskDefinition.taskDefinitionArn' --output text)
    
      echo "   Nova task definition: $NEW_TD_ARN"
    
      # Atualiza o service para nova revisão
      aws ecs update-service --cluster "$CLUSTER" --service "$SERVICE" --task-definition "$NEW_TD_ARN" >/dev/null
      echo "   Service atualizado: $SERVICE"
    done
