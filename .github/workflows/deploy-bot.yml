name: Deploy bot (one or all)

on:
  workflow_dispatch:
    inputs:
      user:
        description: "User (ex: n8w0lff) ou 'all'"
        required: true
        type: string
      image_tag:
        description: "Tag da imagem (default: latest)"
        required: false
        default: "latest"
        type: string

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout infra repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials (role to assume)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: us-east-1

      - name: Parse tfvars for users
        id: parse
        run: |
          set -euo pipefail
          USERS=$(python3 - <<'PY'
          import re, json
          with open('terraform.tfvars','r') as f:
            s=f.read()
          m=re.search(r'users\s*=\s*{(.*?)}', s, re.S)
          if not m:
            print(json.dumps([]))
            raise SystemExit
          block=m.group(1)
          keys=re.findall(r'(\w+)\s*=', block)
          print(json.dumps(keys))
          PY
          )
          echo "users=${USERS}" >> $GITHUB_OUTPUT

      - name: Determine targets
        id: targets
        run: |
          set -euo pipefail
          REQ="${{ github.event.inputs.user }}"
          ALL=$(echo '${{ steps.parse.outputs.users }}' | jq -r '.[]')
          if [ "$REQ" = "all" ]; then
            TARGETS=$(printf "%s\n" $ALL | jq -R . | jq -s .)
          else
            TARGETS=$(printf "%s\n" "$REQ" | jq -R . | jq -s .)
          fi
          echo "targets=${TARGETS}" >> $GITHUB_OUTPUT

      - name: Rollout each target
        run: |
          set -euo pipefail
          IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          PROJECT=$(grep '^project_name' terraform.tfvars | awk -F\" '{print $2}')
          IMAGE=$(grep '^container_image' terraform.tfvars | awk -F\" '{print $2}')
          BASE_IMAGE="${IMAGE%:*}"
          
          for USER in $(echo '${{ steps.targets.outputs.targets }}' | jq -r '.[]'); do
            echo "==> Deploy para user: ${USER}"
          
            CLUSTER="${PROJECT}-cluster"
            SERVICE="${PROJECT}-${USER}"
            FAMILY="${PROJECT}-${USER}"
          
            if ! aws ecs describe-services --cluster "$CLUSTER" --services "$SERVICE" --query 'services[0].serviceName' --output text >/dev/null 2>&1; then
              echo "::error::Service '${SERVICE}' não existe. Execute o workflow 'Infra Apply' para criar o user '${USER}'."
              exit 1
            fi
          
            NEW_IMAGE="${BASE_IMAGE}:${IMAGE_TAG}"
          
            TD_ARN=$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.taskDefinitionArn' --output text)
          
            CONTAINERS_JSON=$(aws ecs describe-task-definition --task-definition "$FAMILY" \
                --query 'taskDefinition.containerDefinitions' \
                | jq '.[0].image = "'"$NEW_IMAGE"'" | [.]')
          
            NEW_TD_ARN=$(aws ecs register-task-definition \
              --family "$FAMILY" \
              --execution-role-arn "$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.executionRoleArn' --output text)" \
              --network-mode "$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.networkMode' --output text)" \
              --requires-compatibilities FARGATE \
              --cpu "$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.cpu' --output text)" \
              --memory "$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.memory' --output text)" \
              --runtime-platform "$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.runtimePlatform' --output json)" \
              --volumes "$(aws ecs describe-task-definition --task-definition "$FAMILY" --query 'taskDefinition.volumes' --output json)" \
              --container-definitions "$CONTAINERS_JSON" \
              --query 'taskDefinition.taskDefinitionArn' --output text )
          
            echo "✔ Nova task definition: $NEW_TD_ARN"
          
            aws ecs update-service \
              --cluster "$CLUSTER" \
              --service "$SERVICE" \
              --task-definition "$NEW_TD_ARN" >/dev/null
          
            echo "✔ Service atualizado: $SERVICE"
          done
